---
title: "Signals Analysis on Video Game Data""
---

- many of these are generic and would work with any FPS. most of these
  I've been imagining while playing overwatch

# Metrics for Overwatch

### Damage/Heals

- total damage given/received, heals given/received
- heal-specific metrics?
  - potential nearby heals that go unhealed.
    - need to look at the total team's (maxHP - HP) tapered by
      distance to player, so the players who need healing but are far
      away don't count.
    - this metric is a pretty simple O(1) arithmetic calculation if
      the player distances are already prepared (and they are
      necessary for other metrics)
    - this is a really good metric for Mercy players, but not Ana
      players ... Ana is hard (not enough experience)

### efficient utilization of controls

  - advanced players always have a better grasp of the controls.
    - e.g. on PS4 Overwatch, i can use four fingers on left & right to
      control all features of mercy with zero inhibition or increase in
      perceived complexity
      - on PC, this is nothing, since you have a Keyboard and full
        range of complexity

### efficient utilization of cooldown

  - advanced players will always exhibited a distribution of ability
    inter-activation times **with a lower bound** than average players
    - this usually means they're engaging the enemy more often
    - novice players will not activate their abilities as frequently

### distance from objective

  - time to attain objective
  - turnover of objective area
  - player/team DPS when holding objective area

### distance from team members

  - also, somehow configure this L2-norm to work with some form of a
    norm generated by the simplicial complex of your team members
    - as well as enemies and all players
    - in this case, the "distance" metric for the L2-norm becomes
      something that measures the area/volume of the polygon

### situational awareness

- measure "intentionality" of FoV movement & correction
  - so, players who can aim the best will need to correct
    minimally. when the adversary starts to evade, this is hard to
    measure.
    - this is a good measure for identifying aim hacks: the player
      just aims too good, with a direct FoV ∂θ path
      - the ∂θ angle should be parameterized with ∂q => this accounts
        for an aim hack that moves player-FoV while accounting player
        change in position
        - to calculate the "directness" of **angular change with
          respect to the player position** this requires a model with
          Lie Algebra

  - at a high-level, this hard to measure, but a simple metric is a
    measure of Field of View volume/spread over time. (FoV =~ camera
    frustum)
    - there are several ways to get a measure of FoV spread/volume
      - calculate volume of FoV, but contrast the FoV frustum for each
        frame and taper the previous frustum's volume.
        - i hope this can be done w/o voxels. i'm almost certain it
          can be.
      - integrate over the ray-trace from player's FoV frustum without
        bouncing the rays (each rays volume counts as a cone, until it
        hits a surface)
        - this can easily be done with the GPU, but is something that
          needs to be computed to a 1D scalar time-series that's
          pushed up to the master server
    - the above doesn't really connect the FoV measure to any
      meaningful re-orientation of the player's view. so if the player
      moves their viewpoint around very quickly, they get a higher
      score on this metric.
      - but advanced players look fast and know when to look
      - novice players will do this much less and poorly
      - it's simply one more feature for ML or statistical models. its
        correlation adds value in conjunction with many other features
  - the same FoV metric, calculated for the team, without counting
    overlap.

### For any scalar values:

- 1D time series
  - ∂-damage & ∂-heals
- metrics regrouped and parameterized by a powerset of team members
  - if these metrics are themselves time-series, this becomes
    expensive, especially for GPU-calculations like FoV volume/spread
    - the GPU does the calculations and pipes the result stream either
      to the Gamestate server (...not) or directly to the Stats server
    - but at somepoint to multiplex the player-specific 1D timeseries
      to a powerset-parameterized (2^p)-D timeseries, which itself
      requires way too much compute to be useful.
      - but not if each 1D FFT spectrum is a set of features, which
        are direct-summed (instead of tensor-product)

- these metrics expand into data that is expensive:
  - (1) to store
  - (2) even moreso to push from Server to Clients
  - thus, some of these metrics, if they are computable/scalable/etc
    should produce streams that are immediately pushed to a Stats
    container from the Gamestate server
    - from the Stats container, they should be tabulated in
      process-bound stream processing or sent to a set of stream
      processing containers for that game.
    - because some of these options aren't so scalable, then

### Difficult Metrics

- damage response time
- accuracy (X) distance
  - useful for players with small spread of fire (tracer, soldier,
    hanzo, widow, etc)

### Signals Analysis to Identify Aim Hacks

- this already exists AFAIK. it's easy to beat, depending on what you
  use to detect it. aim hacks will always modify control motions in
  ways that are appear to be a confusing, merged stream of combined
  mouse input sources where the (dx/dy) of each source is
  characteristically different with each update cycle
  - that is, the player's mouse will always move fairly smoothly
    whereas the aim hacks input modification will not necessarily be
    smooth
  - the combination of both mouse & aim hack will certainly NOT be
    smooth and there will be two distinct jittery streams of combined
    input, where the continuity characteristics of the single
    combined, observed stream are minimal.
    - since the stream is always cycling discrete updates, any notion
      of "continuity" between differentiation/integration is arbitrary
      - therefore, the methods of continuity analysis must account for
        this, but it's very difficult to combine two streams without
        producing artifacts, though they may be difficult to detect
        with a discretized input signal
        - is this true for merged user input streams or for
          artificially modified streams generally?
    - if there is the presence of discontinuous noise in the mouse
      movement (i.e. lots of jitter from one of the dual input sources
      to cancel out the difference between the player's mouse and the
      aim hack's input)
  - another way to defeat aim hacks is to encourage the inclusion of
    accelerometers in the player's mouses. this augments the analysis
    of continuity and consistency
  - the metric above (with Lie Algebra, ∂θ & ∂q) can be used to
    augment aim hack detection with another inputstream independent of
    the input method.

#### autodetect map hacks

  - ... hmmm.. it's hard to detect a high rate of "lucky" guesses
    because the window of time is so large
    - it really depends on whether the hack depends on data via
      network & requests

#### reverse map "hack" (to circumvent lack of API?)

  - what was this idea? it wasn't a hack to cheat ... but may appear
    to be, from the perspective of Overwatch if it required signalling
    many requests for game-state data to the server
    - i think generally, online FPS games prefer to use server
      architectures which are Pub/Sub where the battle.net server
      publishes game-state changes to players
      - ideally, the players can only send UI data
      - however, in practice, with (> 20ms) or especially (> 50ms)
        ping times, there are significant requirements for consensus
  - it was for personal metrics, i think? and for metrics on team
    performance. maybe there's an api with a hook to establish a HTTP
    stream for consistent metrics
    - if not, you can probably get the data, but its requests &
      interaction might resemble a maphack


### Signals Analysis on Density of Individual Team Damage Projection (Potential/Actual)

- overwatch teams that stay together on the map win. it's something
  that always *ALWAYS* distinguishes experienced players. so if I
  played an overwatch game with 6 bronze players, a few of whom were
  smurfs with gold accounts, I KNOW IT IMMEDIATELY.
  - like peewee soccer players bunching up for all the glory, bronze
    players don't know how to position themselves and dont know TO
    position themselves.
    - further, you HAVE TO signal via VOICE to consistenly coordinate
      positioning and esp to longer timescales. if you're team isn't
      on mic, you might as well sign out of that competitive mode, bc
      you ain't going anywhere.
  - those gold smurfs will group up and almost form a PHALANX. they
    project damage onto the DPS field and heals onto the HPS field in
    higher densities, moving as a group.
    - a team that's spread out that encounters a phalanx of 4 to 6,
      the density of damage is so high, they get ripped up and picked
      off immediately.
    - the phalanx team has a major spatial advantage against
      individual players. they stand no chance.
    - the bunched up phalanx-like positioning is great for mercy bc
      she can dart from player to player. if she stays fast, it's real
      hard to hit her, without getting drawn into high density damage.
      - tight formations are also great for stacking character's
        standard AoE abilities. the close & bright chaotic particle
        effects even restrict ability to visually discern/identify
        which abilities/attacks the enemies are using

- how to measure this individually and as a team? the console needs to
  render low-res 2D/3D texture that captures DPS from friends and
  foes.
  - you can calc this for each individual player on their console,
  - then simply ADD in the Stats container as the stream is
    received. the texture should be low-res. or it could be a more
    aggregate value. or it could be a 2D/3D texture that's purely
    relative to the character position ... maybe (if so, then you also
    send q.x, q.y, q.z for each char) ... hmmm
  - the data sent over the stream should be a differential texture,
    similar to a video codec.
  - it's not enough to add the textures together, but to also have a
    metric that really focuses on layered damage. (e.g. multiply
    damage points occupying the same space ... although that's a
    primitive example)

- the reconstructed 2D/3D team/all damage fields are useful for
  the *cheap* gradient-based algorithms for detecting engagement,
  described below.
  - it's expensive to generate/transmit this texture, but cheap to run
    the gradient-based algorithms

### Signals Analysis to Quantify Player Engagement

- the idea here is to determine whether a player is getting in the
  action. imagine football players who are supposed to block, but
  don't approach the enemy fast enough. or soccer players who bunch
  themselves together.
  - so there should be ways of measuring how the players use the space
    of the map. some of these are simple and others are more
    difficult. whether they're computable/scalable in a big data
    setting is another question.
  - in soccer (and basketball to some degree), players prefer to
    spread out for opportunities to pass efficiently, unless they are
    near the ball. in that case, they sociophysically are attracted to
    the ball and indirectly to each other, but they prioritize (1)
    ball control (2) forward pressure (3) controlling the dynamics of
    nearby player positions with their space of potential
    paths/options

- in overwatch and other FPS shooters (depending on the gameplay mode)
  you must engage the enemy, making gains while avoiding losses. you
  can avoid losses all you want, but it doesn't help with
  holding/gaining the point.
  - if you're on the point, you can guarantee the opponents will
    engage you. if you're attacking, you have to find yourself within
    attack range of the opponent. depending on your character, this
    implies various distances of engagement.
    - novice players take their time doing this and are more
      interested with other game mechanics than staying on the edge of
      combat.
      - they are still newbie, so they don't react to engagement well,
        but they don't know to seek it out either ... like a sophomore
        in a college bar, trying to pull some girls.

- ... describe method



### Signals Analysis To Detect Players Who Are Unreasonably Boosting Novices

- high variance in DPS and other "engagement" metrics
  - hopefully simple metrics
- need to pair fps in-game player/team signals/metrics with metadata
  - e.g. identify multiple accounts with same IP address and/or
    PC/Console ID multiple accounts
    - can't play more than one game at a time

### Signals Analysis To Detect Throwing Player Signatures

- detect players who are throwing the game (and other lame passive
  aggressive behaviors)
  - it's easy to detect idle players



# Metagame and Balancing

### Metrics/Measures for Map Balancing

#### Static

- autogenerated manifolds representing the navigable space for each
  character model
  - different characters can naturally navigate different 3D regions
    of the 3D space of the map
    - this may be different when including physics
    - for some overwatch characters

#### Accumulated (via playtesting)



### Methods for Staging Metagame Updates

- planning how to keep the game interesting as minor/major patches
  come out, as well as major expansions
  -

- this is stuff i've thought about for a long time
  - (i've always wondered how blizzard did it...)
  - then, i realized => blizzard must have realized that you're not
    chasing "perfect" but instead you're chasing the "perfect"
    imperfect
    - and using playtesting & game-designer intuition to anticipate
      your players' response in how they adapt their strategy/tactics
      - many players won't notice. some will notice immediately. there
        will be a lot of flux in gameplay style gradually, but at
        differing rates at various strata of skill levels
  - you have to be familiar with how your players will respond,
    tactically and emotionally.
    - you need to be able to identify/discuss the "unnamable" aspects
      of gameplay and strategy. if you can measure these aspects
      that's fantastic.
    - you need to state/quantify your expectations for how change
      metagame will occur, then observe the changes and reflect on
      expected/actual response

  - you need the ideal amount of change: not so much your players get
    jerked around & frustrated, but enough that there's always a
    challenge to adapt.
    - with enough regular players, it may be possible to use big data
      to measure this amount of change and maybe speculate on the
      ideal amount of change

- however, if your process is too automated, then you can't have
  mnemonic values for gameplay mechanics (character HP, ability
  recharge time/cost/ammo)
  - these values need to be easy to remember. time is always easy to
    change (refresh time) because in a player's head, it's a feeling,
    not a number. they may know the ability refresh time, but they
    aren't *counting* it, like they count shots with Zarya when
    lobbing grenades.
  - in other words, "mnemonic" values are easy to remember, they don't
    get changed to 87 then 35 then 50, etc. so, the players can expect
    to *count*. if they can't expect this, then many players won't use
    repeatable tactics based on values and value ratios.
  - it's a wierd phenomenon, like deciding on whether to charge $1.75
    for a coffee before or after taxes, but much more critical to your
    player's cognition during gameplay and the level of effort they
    need to invest to stay up to date.
    - because of the above, you have to

- methodic/pragmatic staging of metagame via game theory
  - video games are ALL about game theory. every last one of them.

- how to deal with
